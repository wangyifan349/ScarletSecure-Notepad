import tkinter as tk
from tkinter import ttk, filedialog, messagebox, simpledialog, font
import threading                 # For threading to avoid UI freezing
import os
import re
import queue                    # Thread-safe queue for UI updates in main thread

from Crypto.Cipher import AES   # AES cipher
from Crypto.Random import get_random_bytes  # Random bytes generator
from Crypto.Protocol.KDF import PBKDF2       # Password-based key derivation function

# === Constants ===
COLOR_BLACK = "#000000"                      # Background color — pure black for eye protection
COLOR_SCARLET = "#FF2400"                    # Text color — scarlet red for font default
COLOR_GOLDEN = "#FFD700"                     # Text color for selection and highlights — golden
COLOR_GREEN_BG = "#008000"                    # Background color for selection and highlights — green
COLOR_HIGHLIGHT_FG = COLOR_GOLDEN            # Highlight foreground color using golden
COLOR_HIGHLIGHT_BG = COLOR_GREEN_BG          # Highlight background color using green

PBKDF2_ITERATIONS = 1000                      # PBKDF2 iterations for key strengthening - security parameter
SALT_SIZE = 16                                # Size of salt in bytes for key derivation

# === Global variables ===
tabs = []                                     # List of dictionaries for each tab (widgets + state)
root = None                                   # Main application window (Tk instance)
notebook = None                               # Notebook widget to manage tabs

ui_queue = queue.Queue()                       # Queue for thread-safe UI updates (executed in main thread)

# === AES encryption helpers ===

def derive_key(password, salt):
    # Derive a strong key using PBKDF2 with SHA-1 (default in PyCryptodome) and given salt
    # Count = PBKDF2_ITERATIONS increases computational cost, enhancing security
    key = PBKDF2(password.encode('utf-8'), salt, dkLen=32, count=PBKDF2_ITERATIONS)
    return key

def encrypt_text(text, password):
    # Encrypt the provided 'text' string with encrypted password-derived key
    salt = get_random_bytes(SALT_SIZE)            # Generate secure random salt for this encryption session
    key = derive_key(password, salt)               # Derive a 256-bit AES key via PBKDF2
    cipher = AES.new(key, AES.MODE_GCM)            # Initialize AES-GCM cipher object with random nonce
    nonce = cipher.nonce                            # Retrieve random nonce generated by cipher
    ciphertext, tag = cipher.encrypt_and_digest(text.encode('utf-8'))   # Encrypt and create authentication tag
    return salt + nonce + tag + ciphertext         # Store salt, nonce, tag and ciphertext concatenated in that order

def decrypt_text(data, password):
    # Decrypt a byte string formatted as salt+nonce+tag+ciphertext with the provided password
    if len(data) < SALT_SIZE + 16 + 16:            # Validate length: minimum 48 bytes (salt + nonce + tag)
        raise ValueError("Invalid encrypted file - data too short.")
    salt = data[:SALT_SIZE]                         # Extract first 16 bytes as salt
    nonce = data[SALT_SIZE:SALT_SIZE+16]           # Next 16 bytes nonce for GCM
    tag = data[SALT_SIZE+16:SALT_SIZE+32]          # Next 16 bytes authentication tag
    ciphertext = data[SALT_SIZE+32:]                # Rest is ciphertext
    key = derive_key(password, salt)                # Derive AES key with supplied password and extracted salt
    cipher = AES.new(key, AES.MODE_GCM, nonce=nonce)  # Create decryptor with same nonce
    decrypted = cipher.decrypt_and_verify(ciphertext, tag)  # Decrypt & verify tag to ensure authentication
    return decrypted.decode('utf-8')                # Return UTF-8 decoded plaintext

# === UI and functional code ===

def create_main_window():
    # Initialize main application window and UI widgets
    global root, notebook
    root = tk.Tk()
    root.title("Scarlet on Black Notepad (AES Encrypted)")  # Window title reflects encryption feature
    root.geometry("900x650")                                 # Default window size (width x height in pixels)

    notebook = ttk.Notebook(root)                            # Notebook widget to hold tabs
    notebook.pack(fill='both', expand=True)                  # Fill available space fully and expand on resize

    create_menu()                                            # Build menu bar and menus
    add_tab("Introduction", intro=True)                      # Add initial Intro tab with instructions

    root.bind_all("<Control-Tab>", next_tab)                 # Ctrl+Tab binding for next tab switching
    root.bind_all("<Control-Shift-Tab>", prev_tab)           # Ctrl+Shift+Tab for previous tab switching

    root.after(100, process_ui_queue)                         # Schedule UI update processing every 100 ms

def create_menu():
    # Construct the application menu bar with File, Edit and View menus with commands
    menu_bar = tk.Menu(root)
    file_menu = tk.Menu(menu_bar, tearoff=0)
    file_menu.add_command(label="New Tab", command=add_tab, accelerator="Ctrl+N")
    file_menu.add_command(label="Open", command=lambda: run_thread(open_file), accelerator="Ctrl+O")
    file_menu.add_command(label="Save", command=lambda: run_thread(save_file), accelerator="Ctrl+S")
    file_menu.add_command(label="Save As", command=lambda: run_thread(save_as_file))
    file_menu.add_separator()
    file_menu.add_command(label="Close Tab", command=close_current_tab, accelerator="Ctrl+W")
    file_menu.add_command(label="Exit", command=root.quit)
    menu_bar.add_cascade(label="File", menu=file_menu)

    edit_menu = tk.Menu(menu_bar, tearoff=0)
    edit_menu.add_command(label="Find", command=open_find_dialog, accelerator="Ctrl+F")
    edit_menu.add_command(label="Find & Replace", command=open_find_replace_dialog, accelerator="Ctrl+H")
    edit_menu.add_separator()
    edit_menu.add_command(label="Undo", command=undo_edit, accelerator="Ctrl+Z")
    edit_menu.add_command(label="Redo", command=redo_edit, accelerator="Ctrl+Y")
    menu_bar.add_cascade(label="Edit", menu=edit_menu)

    view_menu = tk.Menu(menu_bar, tearoff=0)
    view_menu.add_command(label="Increase Font Size", command=increase_font_size, accelerator="Ctrl++")
    view_menu.add_command(label="Decrease Font Size", command=decrease_font_size, accelerator="Ctrl+-")
    menu_bar.add_cascade(label="View", menu=view_menu)

    root.config(menu=menu_bar)                          # Configure menu bar for the root window

    # Keyboard shortcuts globally binded:
    root.bind_all("<Control-n>", lambda e: add_tab())
    root.bind_all("<Control-w>", lambda e: close_current_tab())
    root.bind_all("<Control-f>", lambda e: open_find_dialog())
    root.bind_all("<Control-h>", lambda e: open_find_replace_dialog())
    root.bind_all("<Control-plus>", lambda e: increase_font_size())
    root.bind_all("<Control-minus>", lambda e: decrease_font_size())
    root.bind_all("<Control-=>", lambda e: increase_font_size())    # Often Ctrl+= is Ctrl and plus key

def add_tab(title="Untitled", intro=False):
    # Create a new tab with Text widget, with default colors and font
    frame = tk.Frame(notebook, bg=COLOR_BLACK)          # Frame container for text widget, black background
    notebook.add(frame, text=title)                      # Add tab with provided title label
    notebook.select(frame)                                # Select newly added tab

    text_font_size = 12                                  # Default font size
    text_font = font.Font(family="Consolas", size=text_font_size)  # Monospace font suited for text editing

    text_area = tk.Text(frame, wrap='word', undo=True,
                        fg=COLOR_SCARLET, bg=COLOR_BLACK,
                        insertbackground=COLOR_SCARLET,
                        selectforeground=COLOR_GOLDEN,
                        selectbackground=COLOR_GREEN_BG,
                        font=text_font)
    text_area.pack(fill='both', expand=True)             # Fill tab frame fully with text widget

    scrollbar = tk.Scrollbar(text_area)
    scrollbar.pack(side='right', fill='y')                # Vertical scrollbar attached to text widget
    text_area.config(yscrollcommand=scrollbar.set)        # Connect scrollbar to text widget vertical scrolling
    scrollbar.config(command=text_area.yview)

    # Create context menu for right-click with Find/Replace and Close Tab options
    context_menu = tk.Menu(text_area, tearoff=0)
    context_menu.add_command(label="Find", command=lambda: open_find_dialog(text_area))
    context_menu.add_command(label="Find & Replace", command=lambda: open_find_replace_dialog(text_area))
    context_menu.add_separator()
    context_menu.add_command(label="Close Tab", command=close_current_tab)

    # Display context menu on right click event
    def show_context_menu(event):
        context_menu.tk_popup(event.x_root, event.y_root)
    text_area.bind("<Button-3>", show_context_menu)

    # Bind Ctrl+MouseWheel for font zoom (Windows and Linux mouse wheel events)
    text_area.bind("<Control-MouseWheel>", lambda e: on_ctrl_mousewheel(e, text_area))
    text_area.bind("<Control-Button-4>", lambda e: on_ctrl_mousewheel(e, text_area))  # Linux scroll up
    text_area.bind("<Control-Button-5>", lambda e: on_ctrl_mousewheel(e, text_area))  # Linux scroll down

    # Bracket match highlight on key release and button release, processed in threads for performance
    text_area.bind("<KeyRelease>", lambda e: run_thread(highlight_match, args=(text_area,)))
    text_area.bind("<ButtonRelease>", lambda e: run_thread(highlight_match, args=(text_area,)))

    # Configure text tagging for selection and search highlighting colors
    text_area.tag_config("highlight", foreground=COLOR_HIGHLIGHT_FG, background=COLOR_HIGHLIGHT_BG)
    text_area.tag_config("match", foreground=COLOR_GOLDEN, background=COLOR_GREEN_BG)

    # Enforce selection colors explicitly to maintain eye protection scheme
    text_area.config(selectforeground=COLOR_GOLDEN, selectbackground=COLOR_GREEN_BG)

    filename = None                                     # Initialize filename as None for unsaved tabs

    if intro:
        # Insert informational introductory text on a fresh tab
        intro_text = (
            "Welcome to Scarlet on Black Notepad!\n\n"
            "Instructions:\n"
            "- Hold CTRL + Mouse Wheel to adjust font size quickly.\n"
            "- Right-click in editor for Find, Find & Replace, Close Tab options.\n"
            "- Use tabs (top left) to open and close multiple files.\n"
            "- Selected text appears golden with green background for eye protection.\n"
            "- Matching brackets and found text highlight yellow on green.\n"
            "- All background is pure black (#000000) and text is scarlet red (#FF2400).\n"
            "- Avoids blue colors to reduce eye strain.\n"
            "- Files are AES encrypted on save and require password on open.\n"
        )
        text_area.insert("1.0", intro_text)

    tabs.append({"frame": frame, "text_area": text_area,
                 "font": text_font, "font_size": text_font_size,
                 "filename": filename})

def get_current_tab():
    sel = notebook.select()
    i = 0
    # Find and return the tab dictionary corresponding to current selected notebook tab
    while i < len(tabs):
        if str(tabs[i]["frame"]) == str(sel):
            return tabs[i]
        i += 1
    return None

def close_current_tab():
    tab = get_current_tab()
    if not tab:
        return
    idx = 0
    while idx < len(tabs):
        if tabs[idx] == tab:
            break
        idx += 1
    notebook.forget(tab["frame"])        # Remove tab frame from notebook
    del tabs[idx]                        # Remove tab info from list
    if len(tabs) > 0:
        # Select last tab on close or first if last tab closed
        new_idx = idx - 1 if idx > 0 else 0
        notebook.select(tabs[new_idx]["frame"])

def on_ctrl_mousewheel(event, text_widget):
    # Increase/decrease font size when Ctrl + mouse wheel scroll detected
    tab = None
    i = 0
    while i < len(tabs):
        if tabs[i]["text_area"] == text_widget:
            tab = tabs[i]
            break
        i += 1
    if not tab:
        return "break"
    delta = 0
    if hasattr(event, 'delta'):
        delta = event.delta
    elif event.num == 4:
        delta = 120
    elif event.num == 5:
        delta = -120

    if delta > 0 and tab["font_size"] < 72:        # Upper bound font size limit 72
        tab["font_size"] += 1
        tab["font"].configure(size=tab["font_size"])
    elif delta < 0 and tab["font_size"] > 6:       # Lower bound font size limit 6
        tab["font_size"] -= 1
        tab["font"].configure(size=tab["font_size"])
    return "break"

def run_thread(func, args=()):
    # Run a function in a separate daemon thread to avoid blocking UI
    threading.Thread(target=func, args=args, daemon=True).start()

def process_ui_queue():
    # UI update processor to execute queued UI operations safely in main thread
    while True:
        try:
            func = ui_queue.get_nowait()
        except:
            break
        try:
            func()
        except:
            pass
    root.after(100, process_ui_queue)    # Re-schedule this function every 100ms to process UI tasks

# === File open and save procedures ===

def open_file():
    # Open file dialog runs in thread; locks UI while reading large files avoided
    file_path = filedialog.askopenfilename(filetypes=[("All Files", "*.*")])
    if not file_path:
        return
    try:
        with open(file_path, "rb") as f:
            data = f.read()

        is_encrypted = False
        try:
            text = data.decode('utf-8')       # Attempt decode as plain text to detect encryption
        except:
            is_encrypted = True

        if is_encrypted:
            password = None
            while True:
                password = simpledialog.askstring("Password", "Enter password to decrypt file:", show="*")
                if password is None:          # Cancel opens no file
                    return
                try:
                    text = decrypt_text(data, password)   # Decrypt with password and salt
                    break
                except:
                    messagebox.showerror("Error", "Wrong password or corrupted file, try again.")

        # Update UI in main thread queue to safely interact with Tk widgets
        def update_tab():
            add_tab(os.path.basename(file_path))
            tab = get_current_tab()
            if tab:
                tab["text_area"].delete("1.0", "end")
                tab["text_area"].insert("1.0", text)
                tab["filename"] = file_path
                notebook.tab(tab["frame"], text=os.path.basename(file_path))
        ui_queue.put(update_tab)
    except Exception as e:
        messagebox.showerror("Error", "Failed to open file:\n" + str(e))

def save_file():
    tab = get_current_tab()
    if not tab:
        return
    if tab["filename"]:
        save_file_to_path(tab["filename"], tab)
    else:
        save_as_file()

def save_as_file():
    tab = get_current_tab()
    if not tab:
        return
    file_path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("All Files", "*.*")])
    if not file_path:
        return
    save_file_to_path(file_path, tab)

def save_file_to_path(file_path, tab):
    # Request password for encryption from user before saving
    password = simpledialog.askstring("Password", "Enter password to encrypt file:", show="*")
    if password is None:
        return
    content = tab["text_area"].get("1.0", "end-1c")

    def encrypt_and_save():
        try:
            enc_data = encrypt_text(content, password)            # Encrypt content using AES-GCM + PBKDF2 key
            with open(file_path, "wb") as f:
                f.write(enc_data)                                  # Write encrypted blob to file as bytes
            def update_ui():
                tab["filename"] = file_path
                notebook.tab(tab["frame"], text=os.path.basename(file_path))
                messagebox.showinfo("Save", "File encrypted and saved successfully!")
            ui_queue.put(update_ui)                                # Queue messagebox call in UI thread
        except Exception as err:
            def show_err():
                messagebox.showerror("Error", "Failed to save file:\n"+ str(err))
            ui_queue.put(show_err)
    run_thread(encrypt_and_save)                                # Run encryption and saving off main thread

# === Text highlighting and bracket matching ===

def highlight_match(text_widget):
    def remove_tag():
        text_widget.tag_remove("match", "1.0", "end")
    ui_queue.put(remove_tag)                    # Schedule clearing old match tags safely in UI loop

    pairs = {'(': ')', '[': ']', '{': '}'}
    pos = get_safe_index(text_widget, "insert")
    if not pos:
        return
    line = int(pos.split('.')[0])
    col = int(pos.split('.')[1])

    def get_char_at(idx):
        try:
            return text_widget.get(idx, idx + "+1c")
        except:
            return ""

    char_left = get_char_at(f"{line}.{col-1}") if col > 0 else ""
    char_right = get_char_at(f"{line}.{col}")

    def add_tag(start, end):
        def add():
            text_widget.tag_add("match", start, end)
        ui_queue.put(add)                      # Schedule adding match tag safely in UI thread

    if char_left in pairs:                     # Check left char for opening brackets
        match_idx = find_matching_bracket(text_widget, pos, char_left, pairs[char_left], True)
        if match_idx:
            add_tag(f"{line}.{col-1}", f"{line}.{col}")
            add_tag(match_idx, f"{match_idx}+1c")
    elif char_right in pairs.values():         # Check right char for closing brackets
        reverse_pairs = {}
        for key in pairs:
            reverse_pairs[pairs[key]] = key
        match_idx = find_matching_bracket(text_widget, pos, char_right, reverse_pairs[char_right], False)
        if match_idx:
            add_tag(f"{line}.{col}", f"{line}.{col+1}")
            add_tag(match_idx, f"{match_idx}+1c")

def find_matching_bracket(text_widget, pos, char, match_char, forward):
    stack = 1
    idx = get_safe_index(text_widget, pos)
    if not idx:
        return None
    last_idx = idx
    while True:
        try:
            if forward:
                next_idx = get_safe_index(text_widget, last_idx + "+1c")
            else:
                next_idx = get_safe_index(text_widget, last_idx + "-1c")
        except:
            return None
        if forward:
            if text_widget.compare(next_idx, ">=", "end"):
                break
        else:
            if text_widget.compare(next_idx, "<", "1.0"):
                break
        c = text_widget.get(next_idx, next_idx + "+1c")
        if c == char:
            stack += 1
        elif c == match_char:
            stack -= 1
            if stack == 0:
                return next_idx
        last_idx = next_idx
    return None

def get_safe_index(text_widget, idx):
    try:
        return text_widget.index(idx)
    except:
        return None

# === Find and Replace dialogs implementation ===

def open_find_dialog(text_widget=None):
    tab = get_current_tab()
    if text_widget is None:
        if tab is None:
            return
        text_widget = tab["text_area"]

    dlg = tk.Toplevel(root)
    dlg.title("Find")
    dlg.resizable(False, False)
    dlg.transient(root)

    tk.Label(dlg, text="Find:").grid(row=0, column=0, padx=5, pady=5)
    find_entry = tk.Entry(dlg, width=30)
    find_entry.grid(row=0, column=1, padx=5, pady=5)
    find_entry.focus_set()

    def find_next():
        s = find_entry.get()
        if s == "":
            return
        def do_find():
            text_widget.tag_remove("highlight", "1.0", "end")            # Clear prior highlights
            start_pos = text_widget.index(tk.INSERT)
            idx = text_widget.search(s, start_pos, "end", nocase=1)       # Search with case-insensitive
            if idx == "":
                idx = text_widget.search(s, "1.0", "end", nocase=1)       # Wrap search from top if not found
                if idx == "":
                    ui_queue.put(lambda: messagebox.showinfo("Find", "'%s' not found" % s))
                    return
            end_idx = idx + "+" + str(len(s)) + "c"                     # Calculate end index for highlighting
            text_widget.tag_add("highlight", idx, end_idx)              # Highlight found text
            text_widget.tag_config("highlight", foreground=COLOR_HIGHLIGHT_FG, background=COLOR_HIGHLIGHT_BG)
            text_widget.mark_set(tk.INSERT, end_idx)                    # Move cursor after found text
            text_widget.see(idx)                                         # Scroll to found text

        run_thread(do_find)

    btn_find = tk.Button(dlg, text="Find Next", command=find_next)
    btn_find.grid(row=1, column=0, columnspan=2, pady=5)

    def close_dlg():
        text_widget.tag_remove("highlight", "1.0", "end")              # Remove highlight on dialog close
        dlg.destroy()

    dlg.protocol("WM_DELETE_WINDOW", close_dlg)

def open_find_replace_dialog(text_widget=None):
    tab = get_current_tab()
    if text_widget is None:
        if tab is None:
            return
        text_widget = tab["text_area"]

    dlg = tk.Toplevel(root)
    dlg.title("Find & Replace")
    dlg.geometry("350x150")
    dlg.resizable(False, False)
    dlg.transient(root)

    tk.Label(dlg, text="Find:").grid(row=0, column=0, sticky='e', padx=5, pady=5)
    find_entry = tk.Entry(dlg, width=30)
    find_entry.grid(row=0, column=1, padx=5, pady=5)
    find_entry.focus_set()

    tk.Label(dlg, text="Replace:").grid(row=1, column=0, sticky='e', padx=5, pady=5)
    replace_entry = tk.Entry(dlg, width=30)
    replace_entry.grid(row=1, column=1, padx=5, pady=5)

    def find_next():
        s = find_entry.get()
        if s == "":
            return
        def do_find():
            text_widget.tag_remove("highlight", "1.0", "end")      # Remove previous highlights
            start_pos = text_widget.index(tk.INSERT)
            idx = text_widget.search(s, start_pos, "end", nocase=1)
            if idx == "":
                idx = text_widget.search(s, "1.0", "end", nocase=1)
                if idx == "":
                    ui_queue.put(lambda: messagebox.showinfo("Find", "'%s' not found" % s))
                    return
            end_idx = idx + "+" + str(len(s)) + "c"
            text_widget.tag_add("highlight", idx, end_idx)          # Highlight found text
            text_widget.tag_config("highlight", foreground=COLOR_HIGHLIGHT_FG, background=COLOR_HIGHLIGHT_BG)
            text_widget.mark_set(tk.INSERT, end_idx)                # Move cursor to after found text
            text_widget.see(idx)                                     # Scroll view to found text
        run_thread(do_find)

    def replace_one():
        s = find_entry.get()
        r = replace_entry.get()
        if s == "":
            return
        def do_replace_one():
            pos = text_widget.index(tk.INSERT)
            idx = text_widget.search(s, pos, "end", nocase=1)
            if idx == "":
                ui_queue.put(lambda: messagebox.showinfo("Replace", "'%s' not found" % s))
                return
            end_idx = idx + "+" + str(len(s)) + "c"
            text_widget.delete(idx, end_idx)
            text_widget.insert(idx, r)
            new_end = idx + "+" + str(len(r)) + "c"

            text_widget.tag_remove("highlight", "1.0", "end")      # Clear highlights before new one
            text_widget.tag_add("highlight", idx, new_end)         # Highlight replaced text
            text_widget.tag_config("highlight", foreground=COLOR_HIGHLIGHT_FG, background=COLOR_HIGHLIGHT_BG)

            text_widget.mark_set(tk.INSERT, new_end)
            text_widget.see(idx)
            ui_queue.put(lambda: messagebox.showinfo("Replace", "Replaced one occurrence"))
        run_thread(do_replace_one)

    def replace_all():
        s = find_entry.get()
        r = replace_entry.get()
        if s == "":
            return
        def do_replace_all():
            content = text_widget.get("1.0", "end-1c")
            flags = re.IGNORECASE
            matches = []
            try:
                matches = list(re.finditer(re.escape(s), content, flags=flags))  # Find all regex matches safely
            except:
                ui_queue.put(lambda: messagebox.showerror("Error", "Invalid find pattern"))
                return
            count = len(matches)
            if count == 0:
                ui_queue.put(lambda: messagebox.showinfo("Replace All", "'%s' not found" % s))
                return
            new_content = re.sub(re.escape(s), r, content, flags=flags)      # Replace all
            text_widget.delete("1.0", "end")
            text_widget.insert("1.0", new_content)
            text_widget.tag_remove("highlight", "1.0", "end")                # Remove highlights before fresh

            start_index = "1.0"
            replaced = 0
            # Highlight all replaced substrings one by one in text widget
            while replaced < count:
                idx = text_widget.search(r, start_index, "end", nocase=1)
                if idx == "":
                    break
                end_idx = idx + "+" + str(len(r)) + "c"
                text_widget.tag_add("highlight", idx, end_idx)
                text_widget.tag_config("highlight", foreground=COLOR_HIGHLIGHT_FG, background=COLOR_HIGHLIGHT_BG)
                start_index = end_idx
                replaced += 1
            ui_queue.put(lambda: messagebox.showinfo("Replace All", "Replaced %d occurrences" % count))
        run_thread(do_replace_all)

    btn_find = tk.Button(dlg, text="Find Next", command=find_next)
    btn_find.grid(row=2, column=0, padx=5, pady=5)

    btn_replace = tk.Button(dlg, text="Replace", command=replace_one)
    btn_replace.grid(row=2, column=1, sticky='w', padx=5, pady=5)

    btn_replace_all = tk.Button(dlg, text="Replace All", command=replace_all)
    btn_replace_all.grid(row=3, column=0, columnspan=2, pady=5)

    def close_dlg():
        text_widget.tag_remove("highlight", "1.0", "end")      # Remove all highlights when dialog closed
        dlg.destroy()

    dlg.protocol("WM_DELETE_WINDOW", close_dlg)

# === Undo/Redo functions ===

def undo_edit():
    tab = get_current_tab()
    if tab is None:
        return
    try:
        tab["text_area"].edit_undo()           # Undo last edit command if possible
    except:
        pass

def redo_edit():
    tab = get_current_tab()
    if tab is None:
        return
    try:
        tab["text_area"].edit_redo()           # Redo last undone command if possible
    except:
        pass

# === Tab switching helper functions ===

def next_tab(event=None):
    count = len(tabs)
    if count <= 1:
        return "break"
    current = notebook.index(notebook.select())
    notebook.select((current + 1) % count)     # Cycle forward through tabs
    return "break"

def prev_tab(event=None):
    count = len(tabs)
    if count <= 1:
        return "break"
    current = notebook.index(notebook.select())
    notebook.select((current - 1) % count)     # Cycle backward through tabs
    return "break"

# === Main function to launch app ===

def main():
    create_main_window()
    root.mainloop()

if __name__ == "__main__":
    main()
